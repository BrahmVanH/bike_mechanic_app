/* eslint-disable no-restricted-globals */

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate } from 'workbox-strategies';
import { ApolloClient, InMemoryCache } from '@apollo/client';
import { createHttpLink } from '@apollo/client';
import { NetworkStatus, makeVar } from '@apollo/client';
import { gql } from '@apollo/client';

const cacheName = 'PlushLabCache';

clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
registerRoute(
	// Return false to exempt requests from being fulfilled by index.html.
	({ request, url }) => {
		// If this isn't a navigation, skip.
		if (request.mode !== 'navigate') {
			return false;
		} // If this is a URL that starts with /_, skip.

		if (url.pathname.startsWith('/_')) {
			return false;
		} // If this looks like a URL for a resource, because it contains // a file extension, skip.

		if (url.pathname.match(fileExtensionRegexp)) {
			return false;
		} // Return true to signal that we want to use the handler.

		return true;
	},
	createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
);

// An example runtime caching route for requests that aren't handled by the
// precache, in this case same-origin .png requests like those from in public/
registerRoute(
	// Add in any other file extensions or routing criteria as needed.
	({ url }) => url.origin === self.location.origin && url.pathname.endsWith('.png'), // Customize this strategy as needed, e.g., by changing to CacheFirst.
	new StaleWhileRevalidate({
		cacheName: 'images',
		plugins: [
			// Ensure that once this runtime cache reaches a maximum size the
			// least-recently used images are removed.
			new ExpirationPlugin({ maxEntries: 50 }),
		],
	})
);

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', (event) => {
	if (event.data && event.data.type === 'SKIP_WAITING') {
		self.skipWaiting();
	}
});

// Any other custom service worker logic can go here.

const rockshoxForkInformation = gql`
	query allRockshoxForkOilBathInfo {
		allRockshoxForkOilBathInfo {
			_id
			year
			fork
			model
			damperType
			springType
			wheelSize
			damperUpperVolume
			damperUpperOilWt
			damperLowerVolume
			damperLowerOilWt
			springUpperVolume
			springUpperOilWt
			springLowerVolume
			springLowerOilWt
		}
	}
`;

export const foxForkInformation = gql`
	query allFoxForkOilBathInfo {
		allFoxForkOilBathInfo {
			_id
			year
			model
			damperType
			springType
			wheelSize
			damperUpperVolume
			damperUpperOilWt
			damperLowerVolume
			damperLowerOilWt
			springUpperVolume
			springUpperOilWt
			springLowerVolume
			springLowerOilWt
		}
	}
`;

const fetchAndCacheData = async () => {
	const articleID = 'foxAndRockShoxForkInformation';
	const cacheKey = `article-${articleID}`;

	console.log('creating httpLink...');
	const httpLink = createHttpLink({
		uri: '/graphql',
	});
	console.log(httpLink);

	console.log('instantiating new client');
	const client = new ApolloClient({
		link: httpLink,
		cache: new InMemoryCache(),
	});
	console.log(client);

	try {
		console.log('Fetching rockshox fork data for caching from SW');
		const {
			loading: loadingRockshoxForkData,
			data: allRockshoxForkData,
			error: rockshoxForkDataError,
		} = await client.query({
			query: rockshoxForkInformation,
		});

		console.log('Fetching fox fork data for caching from SW');
		const {
			loading: loadingFoxForkData,
			data: allFoxForkData,
			error: foxForkDataError,
		} = await client.query({
			query: foxForkInformation,
		});

		if (rockshoxForkDataError) {
			console.error('There was an error querying rockshox data', rockshoxForkDataError);
		} else if (foxForkDataError) {
			console.error('There was an error querying fox data', foxForkDataError);
		}
		if (!loadingRockshoxForkData && allRockshoxForkData) {
			console.log('Caching rockshox data');
			caches.open(cacheName).then((cache) => {
				cache.put(cacheKey, new Response(JSON.stringify(allRockshoxForkData)));
			});
		} else {
			console.log('rockshox data not ready yet');
		}
		if (!loadingFoxForkData && allFoxForkData) {
			console.log('Caching fox data');
			caches.open(cacheName).then((cache) => {
				cache.put(cacheKey, new Response(JSON.stringify(allFoxForkData)));
			});
		} else {
			console.log('fox data not available yet');
		}
	} catch (error) {
		console.error('Error fetching data in service worker:', error);
	}
};

// Cache manifest.json and '/' route

const cacheManifest = () => {
	caches.open(cacheName).then((cache) => {
		return cache.addAll(['/', '/manifest.json']);
	});
};

// Listen for SW installation the cache suspension data and manifest for offline user
self.addEventListener('install', (event) => {
	// Perform installation steps
	event.waitUntil(fetchAndCacheData());
	event.waitUntil(cacheManifest());
});

self.addEventListener('fetch', (event) => {
	console.log("event request:", event.request);
	event.respondWith(
		// If no cached response is available, try to fetch the data
		fetch(event.request)
			.then((networkResponse) => {
				console.log("networkResponse: ", networkResponse);
				// Cache the network response for future use
				caches.open(cacheName).then((cache) => {
					console.log("event request inside caches.open: ", event.request);
					console.log("networkResponse in caches.open: ", networkResponse);
					console.log('networkResponse.clone() in caches.open: ', networkResponse.clone());
					console.log("Cache object inside caches.open: ", cache);
					cache.put(event.request, networkResponse.clone());
				});

				// Return the network response
				return networkResponse;
			})
			.catch(async () => {
				// If fetching data from the network fails, serve a fallback response if available
				// You can customize the fallback response as needed
				return caches.match(event.request)
					.then((cachedResponse) => {
						console.log("Netwrok request failed - event.request: ", event.request);
						console.log('Netwrok request failed - cachedResponse: ', cachedResponse);

						if (cachedResponse) {
						console.log('Netwrok request failed - cached response is available... returning', cachedResponse);

							// If a cached response is available, serve it
							return cachedResponse;
						}

						return new Response('Offline content not available');
					})
					.catch(() => {
						return new Response('Offline content not available');
					});
			})
	);
});
